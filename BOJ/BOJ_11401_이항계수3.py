# bOJ 11401 이항 계수 3

'''
조합 등식 활용? => 시간 복잡도상 불가능
(n)    (n - 1)    (n - 1) 
( ) =  (     )  + (     )
(r)    (r - 1)    (  r  )

1. 페르마의 소정리
p가 소수이고  a가 p의 배수가 아니면(=서로소이면) a^(p-1) equivalence 1 (mod p)

=> p가 소수일때, 모듈로 연산에서 a의 역원은 a^(p-2)

2. 모듈로 연산에서 사칙 연산
덧셈, 뺄셈, 곱셈에 대해서는 다음 식이 항상 성립
- 덧셈: (a + b) % M = ((a % M) + (b % M)) % M
- 뺄셈: (a - b) % M = ((a % M) - (b % M)) % M
- 곱셈: (a * b) % M = ((a % M) * (b % M)) % M

나눗셈의 경우에는 곱셈의 역원을 곱하는 방식으로 이뤄진다.
- 곱셈의 역원을 곱한다? 14 / 7 = 2 => 14 * (1/7) = 2
모듈로 곱셈 역원은 항상 존재하는것이 아니라, b와 M이 서로소(coprime)일 때만 존재한다.
- 4 % 2 = 0 이므로...

3. 결론
따라서 모듈로 연산에서 곱셈의 역원을 빠르게 구하는 것이 중요하고
p가 소수일 때 페르마의 소정리를 활용해 곱셈의 역원을 log시간으로 구할수 있다.
'''

def mul(b, r, p):
    c = 1
    while r > 0:
        # 홀수인경우
        if bin(r)[-1] == '1':
            c *= b
            c %= p
        b *= b
        b %= p
        r //= 2
    return c

N, K = map(int, input().split())

a, b = 1, 1
P = 1000000007

for i in range(1, N + 1):
    a *= i
    a %= P

for i in range(1, K + 1):
    b *= i
    b %= P

for i in range(1, N - K + 1):
    b *= i
    b %= P

# c는 b의 모듈로 연산의 곱셈의 역원
c = mul(b, P - 2, P)

ans = (a * c) % P
print(ans)