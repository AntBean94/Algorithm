# BOJ 1557 제곱 ㄴㄴ

'''
아이디어

1. K 번째 제곱 ㄴㄴ수 구하기
- K + S(제곱ㄴㄴ수 이하의 제곱수의 갯수)
ex) K = 13 일 때
19 = 13 + 6(4, 8, 9, 12, 16, 18)

2. 제곱이 포함되는 수의 갯수 세기: S
- 포함-배제 원리
(포함-배제 원리, inclusion-exclusion principle)
조합론에서 여러 개의 합집합의 크기를 구할 때 사용하는 공식.
대표적인 예시로 |AUB| = |A| + |B| - |A∩B|
위의 예시를 일반화한 식이 포함-배제 원리이다.

ex) 20이하의 자연수 중 제곱수의 갯수를 구하기
A2: 2의 제곱수
A3: 3의 제곱수

A2: 4, 8, 12, 16 ...
A3: 9, 18 ...

=> 4 + 2 - 0 = 6

40이하라면? (소수의 제곱수의 배수)
A2: 4, 8, 12, 16, 20, 24, 28, 32, 36, 40 = 10개
A3: 9, 18, 27, 36 = 4개
A5: 25 = 1개

10 + 4 + 1 - 1 - 0 - 0 + 0 = 14개

교집합의 갯수 = N // 제곱수간의 곱

A2: 4
A3: 9
A5: 25
A7: 49
A11: 121
A13: 169
A17: 289
A19: 361
A23: 529
A29: 841
A31: 961
A37: 1369
:
:
A31623(근방의 소수): 약 10억

총 갯수에서
각각의 갯수를 다 더한다.
2개 집합을 모두 뺀다.
3개 집합을 모두 더한다.
반복

1. 2개 집합 빼기
- A2를 기준으로 가능한 최대값을 뽑는다.
- A3 ...
- 끝까지

2. 3개 집합 더하기
- A2, A3, A4
- A2, A3, A5
- 가능한 범위까지 반복

3. 집합의 갯수까지 시행



'''
k = int(input())
t = 0
# 소수의 제곱수 배열
def get_prime(n):
    if n < 2:
        return []
    n += 1
    save = [1] * (n // 2)
    for i in range(3, int(n ** 0.5) + 1, 2):
        if save[i // 2]:
            k = i * i
            save[k // 2::i] = [0] * ((n - k - 1) // (2 * i) + 1)
    return [2] + [(2 * i + 1) for i in range(1, n // 2) if save[i]]
arr = []
arr = get_prime(31623)


# while t <= k: