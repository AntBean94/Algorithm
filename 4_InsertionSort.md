# 4강 삽입 정렬

## Insertion Sort

## "각 숫자를 적절한 위치에 삽입하면 어떨까?"

> 삽입 정렬은 문제를 풀 때 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결한다.
>
> 다른 정렬 방식들은 무조건 위치를 바꾸는 방식이었다면 삽입 정렬은 '필요할 때만' 위치를 바꾼다. => 버블, 선택 정렬보다 빠르다.

---

1. 바라보고 있는 원소의 앞에 있는 값들은 이미 **정렬** 된 상태로 가정한다.
2. 리스트의 시작부터 끝까지 탐색
3. 선택한 원소를 역으로 비교하며 내려간다.
4. 자신보다 작은값을 만나기 전까지 앞뒤로 원소를 교환한다.
5. 반복

---

**Python**

```python
# 삽입 정렬(Insertion Sort) 예제

import sys

arr = [1, 10, 5, 8, 7, 6, 4, 3, 2, 9]

for i in range(1, len(arr)):
    for j in range(i-1, -1, -1):
        if arr[j+1] < arr[j]:
            arr[j+1], arr[j] = arr[j], arr[j+1]
        else:
            break

sys.stdout.write(" ".join(map(str, arr)) + '\n')
```



**C++**

```C++
int main(void) {
  int i, j, temp;
  int array[10] = {1, 10, 5, 8, 7, 6, 4, 3, 2, 9}
  for(i = 0; i < 9; i++) {
    j = i;
    while(array[j] > array[j+1]) {
      temp = array[j];
      array[j] = array[j + 1];
      array[j + 1] = temp;
      j--;
    }
  }
  for(i = 0; i < 10; i++) {
    printf("%d ", array[i])
  }
  return 0;
}
```



## 효율성

> 삽입 정렬은 기본적으로 '정렬이 되어있다고 가정'을 한다는 점에서 특정한 경우에 따라 굉장히 빠른 속도를 자랑한다. 일단 소스코드상 반복문이 두 번 들어가있다는 점에서 복잡도는 **O(N^2)** 이다.

Ex) [2, 3, 4, 5, 6 , 7, 8, 9, 10, 1]

위 예제의 경우 굉장히 빠르게 정렬됨을 알 수 있다.

따라서, 거의 정렬된 상태에 한해서는 어떤 알고리즘 보다도 빠르다는 특징을 가진다.



1. 시간 복잡도: **O(N * N)**

   ```markdown
   10 + 9 + ... + 2 + 1
   
   => N * (N + 1) / 2
   
   => O(N * N)
   ```

   